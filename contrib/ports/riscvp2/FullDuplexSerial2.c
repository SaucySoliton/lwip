// automatically generated by spin2cpp v4.0.5 on Tue Dec 17 14:31:16 2019
// command line: spin2cpp --p2 --ccode FullDuplexSerial2.spin2 

#include <propeller2.h>
#include "FullDuplexSerial2.h"

#if defined(__GNUC__)
#define INLINE__ static inline
#define Yield__() __asm__ volatile( "" ::: "memory" )
#else
#define INLINE__ static
#define Yield__()
#endif

INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }
static  int32_t FullDuplexSerial2_startpasm(FullDuplexSerial2 *self, int32_t mailboxaddress, int32_t rxpin1, int32_t rxbitrate1, int32_t rxmode1, int32_t rxlutstart1, int32_t rxlutsize1, int32_t txpin1, int32_t txbitrate1, int32_t txmode1, int32_t txlutstart1, int32_t txlutsize1, int32_t rxpin2, int32_t rxbitrate2, int32_t rxmode2, int32_t rxlutstart2, int32_t rxlutsize2, int32_t txpin2, int32_t txbitrate2, int32_t txmode2, int32_t txlutstart2, int32_t txlutsize2, int32_t txclocks);

static char dat[] = {
  0x61, 0x01, 0x04, 0xfb, 0x61, 0x03, 0x04, 0xfb, 0x61, 0x05, 0x04, 0xfb, 0x61, 0x07, 0x04, 0xfb, 
  0x61, 0x09, 0x04, 0xfb, 0x61, 0x0b, 0x04, 0xfb, 0x61, 0x0d, 0x04, 0xfb, 0x61, 0x0f, 0x04, 0xfb, 
  0x61, 0x11, 0x04, 0xfb, 0x61, 0x13, 0x04, 0xfb, 0x61, 0x15, 0x04, 0xfb, 0x61, 0x17, 0x04, 0xfb, 
  0x61, 0x19, 0x04, 0xfb, 0x61, 0x1b, 0x04, 0xfb, 0x61, 0x1d, 0x04, 0xfb, 0x61, 0x1f, 0x04, 0xfb, 
  0x61, 0x21, 0x04, 0xfb, 0x61, 0x23, 0x04, 0xfb, 0x61, 0x25, 0x04, 0xfb, 0x61, 0x27, 0x04, 0xfb, 
  0x61, 0x29, 0x04, 0xfb, 0x61, 0x2b, 0x04, 0xfb, 0x00, 0x2c, 0x00, 0xf6, 0x04, 0x2c, 0x04, 0xf1, 
  0x16, 0x30, 0x00, 0xf6, 0x04, 0x30, 0x04, 0xf1, 0x18, 0x34, 0x00, 0xf6, 0x04, 0x34, 0x04, 0xf1, 
  0x1a, 0x38, 0x00, 0xf6, 0x04, 0x38, 0x04, 0xf1, 0x1c, 0x3c, 0x00, 0xf6, 0x04, 0x3c, 0x04, 0xf1, 
  0x1e, 0x40, 0x00, 0xf6, 0x04, 0x40, 0x04, 0xf1, 0x20, 0x44, 0x00, 0xf6, 0x04, 0x44, 0x04, 0xf1, 
  0x22, 0x26, 0x63, 0xfc, 0x20, 0x26, 0x63, 0xfc, 0x1e, 0x26, 0x63, 0xfc, 0x1c, 0x26, 0x63, 0xfc, 
  0x1a, 0x26, 0x63, 0xfc, 0x18, 0x26, 0x63, 0xfc, 0x16, 0x26, 0x63, 0xfc, 0x00, 0x2e, 0x04, 0xf6, 
  0x00, 0x32, 0x04, 0xf6, 0x93, 0x03, 0x08, 0xf2, 0x28, 0x00, 0x90, 0xad, 0x25, 0x00, 0x64, 0xfd, 
  0x40, 0x02, 0x60, 0xfd, 0x80, 0x37, 0x04, 0xf6, 0x01, 0x36, 0x00, 0xf1, 0x01, 0x06, 0x00, 0xfc, 
  0x01, 0x04, 0x10, 0xfc, 0x20, 0x36, 0x60, 0xfd, 0xab, 0xe8, 0x07, 0xf6, 0x25, 0x08, 0x64, 0xfd, 
  0x41, 0x02, 0x60, 0xfd, 0x00, 0x3e, 0x04, 0xf6, 0x00, 0x42, 0x04, 0xf6, 0x93, 0x0d, 0x08, 0xf2, 
  0x10, 0x00, 0x90, 0xad, 0x40, 0x0c, 0x60, 0xfd, 0x06, 0x10, 0x00, 0xfc, 0x06, 0x0e, 0x10, 0xfc, 
  0x41, 0x0c, 0x60, 0xfd, 0x00, 0x82, 0x04, 0xf6, 0x00, 0x84, 0x04, 0xf6, 0x93, 0x17, 0x08, 0xf2, 
  0x28, 0x00, 0x90, 0xad, 0x26, 0x00, 0x64, 0xfd, 0x40, 0x16, 0x60, 0xfd, 0x80, 0x4f, 0x04, 0xf6, 
  0x0b, 0x4e, 0x00, 0xf1, 0x0b, 0x1a, 0x00, 0xfc, 0x0b, 0x18, 0x10, 0xfc, 0x21, 0x4e, 0x60, 0xfd, 
  0xbc, 0xe4, 0x07, 0xf6, 0x26, 0x0a, 0x64, 0xfd, 0x41, 0x16, 0x60, 0xfd, 0x00, 0x52, 0x04, 0xf6, 
  0x00, 0x54, 0x04, 0xf6, 0x93, 0x21, 0x08, 0xf2, 0x10, 0x00, 0x90, 0xad, 0x40, 0x20, 0x60, 0xfd, 
  0x10, 0x24, 0x00, 0xfc, 0x10, 0x22, 0x10, 0xfc, 0x41, 0x20, 0x60, 0xfd, 0xce, 0xe0, 0x07, 0xf6, 
  0x27, 0x02, 0x64, 0xfd, 0x1a, 0x4c, 0x60, 0xfd, 0x15, 0x4c, 0x60, 0xfa, 0x00, 0x26, 0x63, 0xfc, 
  0x93, 0x03, 0x08, 0xf2, 0x48, 0x00, 0x90, 0xad, 0x93, 0x2d, 0x0b, 0xf2, 0x00, 0x2c, 0x03, 0xab, 
  0x16, 0xaa, 0x00, 0xab, 0x93, 0x2d, 0x0b, 0xf2, 0x34, 0x00, 0x90, 0xad, 0x00, 0x99, 0x04, 0xf6, 
  0x01, 0x9b, 0x04, 0xf6, 0xf6, 0xb6, 0x04, 0xf6, 0x55, 0xa0, 0x04, 0xf6, 0x96, 0x9f, 0x04, 0xf6, 
  0x19, 0x8c, 0x04, 0xf6, 0x18, 0xb4, 0x00, 0xf6, 0x04, 0x96, 0x00, 0xf6, 0x05, 0x9c, 0x00, 0xf6, 
  0x17, 0xa2, 0x00, 0xf6, 0x19, 0xa4, 0x00, 0xf6, 0x96, 0x7f, 0x00, 0xf6, 0x58, 0x02, 0xb0, 0xfd, 
  0x93, 0x0d, 0x08, 0xf2, 0x44, 0x00, 0x90, 0xad, 0x93, 0x2f, 0x0b, 0xf2, 0x18, 0x2e, 0x03, 0xab, 
  0x1a, 0x72, 0x00, 0xab, 0x93, 0x2f, 0x0b, 0xf2, 0x30, 0x00, 0x90, 0xad, 0x4f, 0x99, 0x04, 0xf6, 
  0x50, 0x9b, 0x04, 0xf6, 0x39, 0xa0, 0x04, 0xf6, 0x97, 0x9f, 0x04, 0xf6, 0x1f, 0xa6, 0x04, 0xf6, 
  0x21, 0x8c, 0x04, 0xf6, 0x0a, 0x9c, 0x00, 0xf6, 0x09, 0x96, 0x00, 0xf6, 0x1f, 0xa2, 0x00, 0xf6, 
  0x21, 0xa4, 0x00, 0xf6, 0x97, 0x7f, 0x00, 0xf6, 0x48, 0x03, 0xb0, 0xfd, 0x93, 0x17, 0x08, 0xf2, 
  0x48, 0x00, 0x90, 0xad, 0x93, 0x31, 0x0b, 0xf2, 0x1c, 0x30, 0x03, 0xab, 0x1e, 0xb0, 0x00, 0xab, 
  0x93, 0x31, 0x0b, 0xf2, 0x34, 0x00, 0x90, 0xad, 0x03, 0x99, 0x04, 0xf6, 0x04, 0x9b, 0x04, 0xf6, 
  0xf8, 0xb6, 0x04, 0xf6, 0x58, 0xa0, 0x04, 0xf6, 0x98, 0x9f, 0x04, 0xf6, 0x42, 0x8c, 0x04, 0xf6, 
  0x20, 0xb4, 0x00, 0xf6, 0x0e, 0x96, 0x00, 0xf6, 0x0f, 0x9c, 0x00, 0xf6, 0x41, 0xa2, 0x00, 0xf6, 
  0x42, 0xa4, 0x00, 0xf6, 0x98, 0x7f, 0x00, 0xf6, 0xbc, 0x01, 0xb0, 0xfd, 0x93, 0x21, 0x08, 0xf2, 
  0x0c, 0xff, 0x9f, 0xad, 0x93, 0x33, 0x0b, 0xf2, 0x20, 0x32, 0x03, 0xab, 0x22, 0x80, 0x00, 0xab, 
  0x93, 0x33, 0x0b, 0xf2, 0xf8, 0xfe, 0x9f, 0xad, 0x52, 0x99, 0x04, 0xf6, 0x53, 0x9b, 0x04, 0xf6, 
  0x40, 0xa0, 0x04, 0xf6, 0x99, 0x9f, 0x04, 0xf6, 0x29, 0xa6, 0x04, 0xf6, 0x2a, 0x8c, 0x04, 0xf6, 
  0x14, 0x9c, 0x00, 0xf6, 0x13, 0x96, 0x00, 0xf6, 0x29, 0xa2, 0x00, 0xf6, 0x2a, 0xa4, 0x00, 0xf6, 
  0x99, 0x7f, 0x00, 0xf6, 0xac, 0x02, 0xb0, 0xfd, 0xc4, 0xfe, 0x9f, 0xfd, 0x01, 0x36, 0x88, 0xfa, 
  0x18, 0x36, 0x44, 0xf0, 0x17, 0x3a, 0x00, 0xf6, 0x05, 0x3a, 0x00, 0xf7, 0x19, 0x3a, 0x08, 0xf2, 
  0xf5, 0xff, 0x3b, 0xab, 0x17, 0x70, 0x00, 0xf6, 0x03, 0x70, 0x04, 0xf5, 0x17, 0x3a, 0x00, 0xf6, 
  0x02, 0x3a, 0x44, 0xf0, 0x04, 0x3a, 0x00, 0xf1, 0x1d, 0x5a, 0xa0, 0xfa, 0x2d, 0x70, 0x64, 0xf9, 
  0x1b, 0x00, 0xc0, 0xf8, 0x1d, 0x5a, 0x30, 0xfc, 0x05, 0x2e, 0x00, 0xf7, 0xf5, 0xff, 0x3b, 0xfb, 
  0x0b, 0x4e, 0x88, 0xfa, 0x18, 0x4e, 0x44, 0xf0, 0x41, 0x50, 0x00, 0xf6, 0x0f, 0x50, 0x00, 0xf7, 
  0x42, 0x50, 0x08, 0xf2, 0xf3, 0xff, 0x3b, 0xab, 0x18, 0x4e, 0x44, 0xf0, 0x41, 0x76, 0x00, 0xf6, 
  0x03, 0x76, 0x04, 0xf5, 0x41, 0x50, 0x00, 0xf6, 0x02, 0x50, 0x44, 0xf0, 0x0e, 0x50, 0x00, 0xf1, 
  0x28, 0x7c, 0xa0, 0xfa, 0x3e, 0x76, 0x64, 0xf9, 0x27, 0x00, 0xc0, 0xf8, 0x28, 0x7c, 0x30, 0xfc, 
  0x0f, 0x82, 0x00, 0xf7, 0xf3, 0xff, 0x3b, 0xfb, 0x93, 0x0d, 0x08, 0xf2, 0x24, 0x00, 0x90, 0xad, 
  0x21, 0x3e, 0x08, 0xf2, 0x1c, 0x00, 0x90, 0xad, 0x06, 0x46, 0x98, 0xfa, 0x14, 0x00, 0x90, 0xcd, 
  0x21, 0x5c, 0x00, 0xf6, 0x09, 0x78, 0x00, 0xf6, 0x3c, 0x00, 0xb0, 0xfd, 0x0a, 0x42, 0x00, 0xf7, 
  0x06, 0x48, 0x20, 0xfc, 0x93, 0x21, 0x08, 0xf2, 0x24, 0x00, 0x90, 0xad, 0x2a, 0x52, 0x08, 0xf2, 
  0x1c, 0x00, 0x90, 0xad, 0x10, 0x46, 0x98, 0xfa, 0x14, 0x00, 0x90, 0xcd, 0x2a, 0x5c, 0x00, 0xf6, 
  0x13, 0x78, 0x00, 0xf6, 0x10, 0x00, 0xb0, 0xfd, 0x14, 0x54, 0x00, 0xf7, 0x10, 0x48, 0x20, 0xfc, 
  0x15, 0x4c, 0x60, 0xfa, 0xf1, 0xff, 0x3b, 0xfb, 0x2e, 0x4a, 0x00, 0xf6, 0x03, 0x4a, 0x04, 0xf5, 
  0x2e, 0x8e, 0x00, 0xf6, 0x02, 0x8e, 0x44, 0xf0, 0x3c, 0x8e, 0x00, 0xf1, 0x47, 0x90, 0xa0, 0xfa, 
  0x48, 0x4a, 0x6c, 0xf9, 0x48, 0x48, 0xe0, 0x08, 0x51, 0x88, 0x00, 0xf6, 0x52, 0xa2, 0x58, 0xf2, 
  0x4e, 0x88, 0x00, 0xc1, 0x01, 0x88, 0x04, 0xc1, 0x52, 0x88, 0x80, 0x01, 0x03, 0x7a, 0x04, 0xf5, 
  0x02, 0x86, 0x44, 0xf0, 0x4b, 0x86, 0x00, 0x01, 0x0c, 0x00, 0xb0, 0xfd, 0x05, 0x32, 0x00, 0x07, 
  0x04, 0x00, 0xb0, 0xfd, 0x0f, 0x84, 0x00, 0x07, 0x52, 0x7a, 0x00, 0xf6, 0x52, 0x86, 0x00, 0xf6, 
  0xd8, 0xff, 0xbf, 0xfd, 0x43, 0x74, 0xa0, 0xfa, 0x3a, 0x7a, 0x6c, 0xf9, 0x3a, 0x88, 0xe0, 0x08, 
  0x16, 0x88, 0x60, 0xfc, 0x93, 0x2d, 0x03, 0xf6, 0x00, 0x2c, 0x63, 0x0c, 0x1e, 0x88, 0x60, 0xfc, 
  0x93, 0x31, 0x03, 0xf6, 0x1c, 0x30, 0x63, 0x0c, 0x00, 0x7e, 0x5c, 0xf2, 0x48, 0x00, 0x90, 0x3d, 
  0x94, 0x7f, 0x08, 0xf2, 0x10, 0x00, 0x90, 0x5d, 0x93, 0x89, 0x00, 0xf6, 0x52, 0xa2, 0x08, 0xf2, 
  0x2d, 0xb6, 0x60, 0x5d, 0x2c, 0x98, 0x60, 0xfd, 0x3f, 0x7e, 0x60, 0xf6, 0x3f, 0xac, 0x00, 0xf6, 
  0x08, 0xac, 0x44, 0xf0, 0xff, 0x7e, 0x04, 0xf5, 0x03, 0x7e, 0x0c, 0xf2, 0x10, 0x00, 0x90, 0xad, 
  0x04, 0x7e, 0x0c, 0xf2, 0x4e, 0x88, 0x00, 0xa6, 0x2c, 0x98, 0x60, 0xad, 0x2c, 0x9a, 0x60, 0xfd, 
  0x54, 0xff, 0xbf, 0xfd, 0x2c, 0x98, 0x60, 0xfd, 0x00, 0xb2, 0x04, 0xf6, 0x00, 0x80, 0x00, 0xff, 
  0x00, 0x7e, 0x5c, 0xf2, 0x01, 0xb2, 0x04, 0x36, 0x00, 0x00, 0x01, 0xff, 0x00, 0x7e, 0x5c, 0xf2, 
  0x02, 0xb2, 0x04, 0x36, 0xff, 0x7f, 0x00, 0xff, 0xff, 0x7f, 0x04, 0xf5, 0x00, 0x7e, 0x0c, 0xf2, 
  0x2c, 0x9a, 0x60, 0xad, 0x52, 0xa2, 0x58, 0xf2, 0x4e, 0x7a, 0x00, 0xc6, 0x01, 0x7a, 0x04, 0xc1, 
  0x00, 0x7a, 0x04, 0xf6, 0x2d, 0x00, 0x6c, 0xad, 0x2d, 0xb6, 0x60, 0xfd, 0x01, 0xb2, 0x0c, 0xf2, 
  0x0c, 0x00, 0x90, 0xad, 0x02, 0xb2, 0x0c, 0xf2, 0x04, 0x00, 0x90, 0xad, 0x64, 0x00, 0x90, 0xfd, 
  0x01, 0x7e, 0x0c, 0xf2, 0x50, 0x00, 0x90, 0xad, 0x0d, 0x88, 0x0c, 0xf2, 0x48, 0x00, 0x90, 0xad, 
  0x0a, 0x88, 0x0c, 0xf2, 0x40, 0x00, 0x90, 0xad, 0x01, 0xb2, 0x0c, 0xf2, 0x44, 0x00, 0x90, 0xad, 
  0x01, 0x9b, 0x0c, 0xf2, 0x18, 0x00, 0x90, 0x5d, 0x24, 0x42, 0x60, 0xfd, 0x06, 0x46, 0x98, 0xfa, 
  0xf8, 0xff, 0x9f, 0xcd, 0x06, 0x88, 0x20, 0xfc, 0x24, 0x40, 0x60, 0xfd, 0x24, 0x00, 0x90, 0xfd, 
  0x24, 0x42, 0x60, 0xfd, 0x10, 0x46, 0x98, 0xfa, 0xf8, 0xff, 0x9f, 0xcd, 0x10, 0x88, 0x20, 0xfc, 
  0x24, 0x40, 0x60, 0xfd, 0x0c, 0x00, 0x90, 0xfd, 0x00, 0x88, 0x04, 0xf6, 0x04, 0x00, 0xb0, 0xfd, 
  0x2c, 0x9a, 0x60, 0xfd, 0x00, 0xa0, 0x94, 0xf9, 0x00, 0x88, 0x40, 0xfc, 0x00, 0xa0, 0x8c, 0xf9, 
  0x01, 0x00, 0x04, 0xf1, 0x00, 0x9e, 0x8c, 0xf9, 0x01, 0x00, 0x84, 0x01, 0x1a, 0x88, 0x60, 0xfc, 
  0x93, 0x2f, 0x03, 0xf6, 0x18, 0x2e, 0x63, 0x0c, 0x22, 0x88, 0x60, 0xfc, 0x93, 0x33, 0x03, 0xf6, 
  0x20, 0x32, 0x63, 0x0c, 0x00, 0x7e, 0x5c, 0xf2, 0x34, 0x00, 0x90, 0x3d, 0x3f, 0x7e, 0x60, 0xf6, 
  0x3f, 0xac, 0x00, 0xf6, 0x08, 0xac, 0x44, 0xf0, 0xff, 0x7e, 0x04, 0xf5, 0x02, 0x7e, 0x0c, 0xf2, 
  0xac, 0x00, 0x90, 0xad, 0x03, 0x7e, 0x0c, 0xf2, 0xb8, 0x00, 0x90, 0xad, 0x04, 0x7e, 0x0c, 0xf2, 
  0x4e, 0x88, 0x00, 0xa6, 0x2c, 0x98, 0x60, 0xad, 0x05, 0x7e, 0x0c, 0xf2, 0x2c, 0x9a, 0x60, 0x5d, 
  0x51, 0x86, 0x00, 0xf6, 0x4e, 0x86, 0x00, 0xf7, 0x52, 0x86, 0x08, 0xf2, 0x2d, 0x00, 0x64, 0xad, 
  0x00, 0xa0, 0x8c, 0xf9, 0x93, 0x01, 0x08, 0xf2, 0x0c, 0x00, 0x90, 0x5d, 0x3f, 0x88, 0x00, 0xf6, 
  0x3c, 0x00, 0xb0, 0xfd, 0x2c, 0x9a, 0x60, 0xfd, 0x00, 0x7e, 0x5c, 0xf2, 0x2c, 0x9a, 0x60, 0xed, 
  0x00, 0x88, 0x04, 0xf6, 0x00, 0xa0, 0x94, 0xf9, 0x00, 0x88, 0xc0, 0xfa, 0x00, 0x9e, 0x8c, 0xf9, 
  0x95, 0x01, 0x08, 0xf2, 0x00, 0x9e, 0x8c, 0x59, 0x01, 0x00, 0x84, 0x51, 0x00, 0x88, 0x0c, 0xa2, 
  0x2c, 0x9a, 0x60, 0xad, 0x08, 0x00, 0xb0, 0xfd, 0x00, 0xa0, 0x8c, 0xf9, 0x01, 0x00, 0x04, 0x01, 
  0x4b, 0x86, 0x00, 0xf6, 0x02, 0x86, 0x64, 0xf0, 0x51, 0x86, 0x00, 0xf1, 0x43, 0x7a, 0x00, 0xf6, 
  0x03, 0x7a, 0x04, 0xf5, 0x02, 0x86, 0x44, 0xf0, 0x43, 0x74, 0xa0, 0xfa, 0x3a, 0x7a, 0x64, 0xf9, 
  0x44, 0x00, 0xc0, 0xf8, 0x43, 0x74, 0x30, 0xfc, 0x00, 0xa6, 0x8c, 0xf9, 0x4e, 0x00, 0x00, 0x07, 
  0x93, 0x89, 0x00, 0xf6, 0x51, 0x86, 0x00, 0xf6, 0x4e, 0x86, 0x00, 0xf7, 0x52, 0x86, 0x08, 0xf2, 
  0x2c, 0x98, 0x60, 0xad, 0x04, 0x00, 0xb0, 0xfd, 0x2c, 0x98, 0x60, 0xfd, 0x78, 0xfd, 0xbf, 0xfd, 
  0x44, 0x88, 0x60, 0xf6, 0x4e, 0x88, 0x00, 0xf1, 0x01, 0x88, 0x04, 0x01, 0xff, 0xff, 0xff, 0xff, 
  0xfe, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
};
//
// =======================================================================
//
// -----------------------------------------------------------------------
// stop pasm cog if already running
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_stop(FullDuplexSerial2 *self)
{
  if (self->cog) {
    _cogstop(self->cog - 1);
    self->cog = 0;
  }
}

//
// -----------------------------------------------------------------------
// return parameter address of instance
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_mailboxaddress(void)
{
  return ((int32_t)(((int32_t *)&dat[1624])));
}

//
// -----------------------------------------------------------------------
// start with default serial pins and mode
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_start_default(FullDuplexSerial2 *self, int32_t baudrate)
{
  return FullDuplexSerial2_start(self, 63, 62, 0, baudrate);
}

//
// -----------------------------------------------------------------------
// use this to start a 1 port driver with 1024 bytes buffer each channel
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_start(FullDuplexSerial2 *self, int32_t rxpin, int32_t txpin, int32_t mode, int32_t baudrate)
{
  int32_t 	bitrate, rxmode1, txmode1;
  // mode bit 0 = invert rx
  // mode bit 1 = invert tx
  // mode bit 2 = open-drain/source tx - not supported yet
  // mode bit 3 = ignore tx echo on rx - not supported yet
  bitrate = 7 + ((_clockfreq() / baudrate) << 16);
  rxmode1 = FULLDUPLEXSERIAL2__RX_MODE_DEFAULT;
  txmode1 = FULLDUPLEXSERIAL2__TX_MODE_DEFAULT;
  if (mode > (-1)) {
    if ((mode & 0x1) > 0) {
      rxmode1 = FULLDUPLEXSERIAL2__RX_MODE_INVERTED;
    }
    if ((mode & 0x2) > 0) {
      txmode1 = FULLDUPLEXSERIAL2__TX_MODE_INVERTED;
    }
  }
  return FullDuplexSerial2_startpasm(self, (int32_t)(&self->rx1cmd), rxpin, bitrate, rxmode1, 0, 1023, txpin, bitrate, txmode1, 256, 1023, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100);
}

//
// -----------------------------------------------------------------------
// use this to start a 2 port driver with 512 bytes buffer each channel
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_start2(FullDuplexSerial2 *self, int32_t rxpin1, int32_t txpin1, int32_t mode1, int32_t baudrate1, int32_t rxpin2, int32_t txpin2, int32_t mode2, int32_t baudrate2)
{
  int32_t 	bitrate1, bitrate2, rxmode1, rxmode2, txmode1, txmode2;
  // mode bit 0 = invert rx
  // mode bit 1 = invert tx
  // mode bit 2 = open-drain/source tx - not supported yet
  // mode bit 3 = ignore tx echo on rx - not supported yet
  bitrate1 = 7 + ((_clockfreq() / baudrate1) << 16);
  bitrate2 = 7 + ((_clockfreq() / baudrate2) << 16);
  rxmode1 = FULLDUPLEXSERIAL2__RX_MODE_DEFAULT;
  txmode1 = FULLDUPLEXSERIAL2__TX_MODE_DEFAULT;
  if (mode1 > (-1)) {
    if ((mode1 & 0x1) > 0) {
      rxmode1 = FULLDUPLEXSERIAL2__RX_MODE_INVERTED;
    }
    if ((mode1 & 0x2) > 0) {
      txmode1 = FULLDUPLEXSERIAL2__TX_MODE_INVERTED;
    }
  }
  rxmode2 = FULLDUPLEXSERIAL2__RX_MODE_DEFAULT;
  txmode2 = FULLDUPLEXSERIAL2__TX_MODE_DEFAULT;
  if (mode2 > (-1)) {
    if ((mode2 & 0x1) > 0) {
      rxmode2 = FULLDUPLEXSERIAL2__RX_MODE_INVERTED;
    }
    if ((mode2 & 0x2) > 0) {
      txmode2 = FULLDUPLEXSERIAL2__TX_MODE_INVERTED;
    }
  }
  return FullDuplexSerial2_startpasm(self, (int32_t)(&self->rx1cmd), rxpin1, bitrate1, rxmode1, 0, 511, txpin1, bitrate1, txmode1, 128, 511, rxpin2, bitrate2, rxmode2, 256, 511, txpin2, bitrate2, txmode2, 384, 511, 100);
}

//
// -----------------------------------------------------------------------
// use this to start whatever combination you want
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_startext(FullDuplexSerial2 *self, int32_t rxpin1, int32_t txpin1, int32_t rxbaudrate1, int32_t txbaudrate1, int32_t rxconfig1, int32_t txconfig1, int32_t rxlutstart1, int32_t rxlutsize1, int32_t txlutstart1, int32_t txlutsize1, int32_t rxpin2, int32_t txpin2, int32_t rxbaudrate2, int32_t txbaudrate2, int32_t rxconfig2, int32_t txconfig2, int32_t rxlutstart2, int32_t rxlutsize2, int32_t txlutstart2, int32_t txlutsize2, int32_t txclocks)
{
  int32_t 	rxmode1, txmode1, rxmode2, txmode2, rxbitrate1, txbitrate1, rxbitrate2, txbitrate2;
  // 
  // WARNING
  // =======
  // HERE RXMODE AND TXMODE ARE THE SMARTPIN CONFIGURATION, NOT THE FULLDUPLEX SERIAL MODE
  // 
  if (rxconfig1 == (-1)) {
    rxmode1 = FULLDUPLEXSERIAL2__RX_MODE_DEFAULT;
  } else {
    rxmode1 = rxconfig1;
  }
  if (txconfig1 == (-1)) {
    txmode1 = FULLDUPLEXSERIAL2__TX_MODE_DEFAULT;
  } else {
    txmode1 = txconfig1;
  }
  if (rxconfig2 == (-1)) {
    rxmode2 = FULLDUPLEXSERIAL2__RX_MODE_DEFAULT;
  } else {
    rxmode2 = rxconfig2;
  }
  if (txconfig2 == (-1)) {
    txmode2 = FULLDUPLEXSERIAL2__TX_MODE_DEFAULT;
  } else {
    txmode2 = txconfig2;
  }
  rxbitrate1 = 7 + ((_clockfreq() / rxbaudrate1) << 16);
  txbitrate1 = 7 + ((_clockfreq() / txbaudrate1) << 16);
  rxbitrate2 = 7 + ((_clockfreq() / rxbaudrate2) << 16);
  txbitrate2 = 7 + ((_clockfreq() / txbaudrate2) << 16);
  return FullDuplexSerial2_startpasm(self, (int32_t)(&self->rx1cmd), rxpin1, rxbitrate1, rxmode1, rxlutstart1, rxlutsize1, txpin1, txbitrate1, txmode1, txlutstart1, txlutsize1, rxpin2, rxbitrate2, rxmode2, rxlutstart2, rxlutsize2, txpin2, txbitrate2, txmode2, txlutstart2, txlutsize2, txclocks);
}

//
// -----------------------------------------------------------------------
// this provides the parameter array needed to start the pasm cog on the stack
// -----------------------------------------------------------------------
//
static int32_t FullDuplexSerial2_startpasm(FullDuplexSerial2 *self, int32_t mailboxaddress, int32_t rxpin1, int32_t rxbitrate1, int32_t rxmode1, int32_t rxlutstart1, int32_t rxlutsize1, int32_t txpin1, int32_t txbitrate1, int32_t txmode1, int32_t txlutstart1, int32_t txlutsize1, int32_t rxpin2, int32_t rxbitrate2, int32_t rxmode2, int32_t rxlutstart2, int32_t rxlutsize2, int32_t txpin2, int32_t txbitrate2, int32_t txmode2, int32_t txlutstart2, int32_t txlutsize2, int32_t txclocks)
{
  int32_t result = 0;
  FullDuplexSerial2_stop(self);
  self->hmailboxaddress = mailboxaddress;
  self->hrxpin1 = rxpin1;
  self->hrxbitrate1 = rxbitrate1;
  self->hrxmode1 = rxmode1;
  self->hrxlutstart1 = rxlutstart1;
  self->hrxlutsize1 = rxlutsize1;
  self->htxpin1 = txpin1;
  self->htxbitrate1 = txbitrate1;
  self->htxmode1 = txmode1;
  self->htxlutstart1 = txlutstart1;
  self->htxlutsize1 = txlutsize1;
  self->hrxpin2 = rxpin2;
  self->hrxbitrate2 = rxbitrate2;
  self->hrxmode2 = rxmode2;
  self->hrxlutstart2 = rxlutstart2;
  self->hrxlutsize2 = rxlutsize2;
  self->htxpin2 = txpin2;
  self->htxbitrate2 = txbitrate2;
  self->htxmode2 = txmode2;
  self->htxlutstart2 = txlutstart2;
  self->htxlutsize2 = txlutsize2;
  self->htxclocks = txclocks;
  // Mailbox. So now I use long[long[]] to access the first long in the later used mailbox as Flag
  // set flag (0) to know if the started cog has read its parameters
  ((int32_t *)(&self->hmailboxaddress)[0])[0] = 0;
  self->cog = _cognew((int32_t)(((int32_t *)&dat[0])), (int32_t)(&self->hmailboxaddress)) + 1;
  if (self->cog) {
    // if I was able to start the COG
    while (!(((int32_t *)(&self->hmailboxaddress)[0])[0] == (-1))) {
      Yield__();
    }
    // I wait until Flag states cog is done reading parameter and ready to roll  (-1)
    // now start done
    result = 1;
  }
  return result;
}

//
// =======================================================================
// All of these routines need a port value, 0 for rx1 and tx1, 1 for rx2 and tx2 
// if you don't provide a port value fastspin will use 0 using rx1 and tx1 
// =======================================================================
//
// =======================================================================
//
// Basic I/O
//
// ================================ RX ===================================
//
// -----------------------------------------------------------------------
// returns nothing flushes rx buffer (waits until buffer completely empty)
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_rxflush(FullDuplexSerial2 *self, int32_t port)
{
  while (FullDuplexSerial2_rxcheck(self, port) >= 0) {
    Yield__();
  }
}

//
// -----------------------------------------------------------------------
// check if byte received (never waits)
// returns -1 if no byte, otherwise received byte
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_rxcheck(FullDuplexSerial2 *self, int32_t port)
{
  return FullDuplexSerial2_read(self, 0, -2, port);
}

//
// -----------------------------------------------------------------------
// find out if a byte is ready to receive
// returns 0 if none ready
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_rxready(FullDuplexSerial2 *self, int32_t port)
{
  return FullDuplexSerial2_rxcount(self, port);
}

//
// -----------------------------------------------------------------------
// Wait ms milliseconds for a byte to be received
// returns -1 if no byte received, $00..$FF if byte
// -----------------------------------------------------------------------
//
// FIXME PUB rxtime(ms) : rxbyte | t
// FIXME   t := cnt
// FIXME  repeat until (rxbyte := rxcheck) => 0 or (cnt - t) / (clkfreq / 1000) > ms
//
// -----------------------------------------------------------------------
// receive a byte (waits until done)
// returns received byte
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_rx(FullDuplexSerial2 *self, int32_t port)
{
  int32_t _parm__0001[2];
  _parm__0001[0] = 0;
  _parm__0001[1] = port;
  FullDuplexSerial2_read(self, (int32_t)(&_parm__0001[0]), 1, _parm__0001[1]);
  return _parm__0001[0];
}

//
// -----------------------------------------------------------------------
// receive a string ending with CR or NL or max size (waits until done)
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_strin(FullDuplexSerial2 *self, int32_t hubaddress, int32_t size, int32_t echo, int32_t port)
{
  FullDuplexSerial2_strin_async(self, hubaddress, size, echo, port);
  return FullDuplexSerial2_wait_rxready(self, port, -1);
}

//
// -----------------------------------------------------------------------
// receive a block from serial to memory of given size in bytes (waits until done)
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_read(FullDuplexSerial2 *self, int32_t hubaddress, int32_t size, int32_t port)
{
  FullDuplexSerial2_read_async(self, hubaddress, size, port);
  return FullDuplexSerial2_wait_rxready(self, port, -1);
}

//
// ================================ TX ===================================
//
// -----------------------------------------------------------------------
// Flush transmit buffer (waits until buffer completely send)
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_txflush(FullDuplexSerial2 *self, int32_t port)
{
  int32_t 	bsize;
  bsize = FullDuplexSerial2_txsize(self, port);
  while (FullDuplexSerial2_txcount(self, port) < bsize) {
    Yield__();
  }
}

//
// -----------------------------------------------------------------------
// check if byte can be send (never waits)
// returns -1 if no space in buffer otherwise number of bytes free in send buffer
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_txcheck(FullDuplexSerial2 *self, int32_t port)
{
  return FullDuplexSerial2_write(self, 0, -2, port);
}

//
// -----------------------------------------------------------------------
// transmit a byte (waits until done)
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_tx(FullDuplexSerial2 *self, int32_t val, int32_t port)
{
  FullDuplexSerial2_write(self, -1, val, port);
}

//
// -----------------------------------------------------------------------
// transmit a string (waits until done)
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_str(FullDuplexSerial2 *self, const char *s, int32_t port)
{
  FullDuplexSerial2_write(self, (int32_t)s, -5, port);
}

//
// -----------------------------------------------------------------------
// transmit a block from memory to serial of given size in bytes (waits until done)
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_writehex(FullDuplexSerial2 *self, int32_t hubaddress, int32_t size, int32_t port)
{
  int32_t 	tmp, count, _idx__0002;
  tmp = hubaddress;
  count = size / 4;
  for(_idx__0002 = count; _idx__0002 != 0; --_idx__0002) {
    FullDuplexSerial2_hex(self, ((int32_t *)tmp)[0], 8, port);
    tmp = tmp + 4;
  }
  return FullDuplexSerial2_wait_txready(self, port);
}

//
// -----------------------------------------------------------------------
// transmit a block from memory to serial of given size in bytes (waits until done)
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_write(FullDuplexSerial2 *self, int32_t hubaddress, int32_t size, int32_t port)
{
  FullDuplexSerial2_write_async(self, hubaddress, size, port);
  return FullDuplexSerial2_wait_txready(self, port);
}

// -----------------------------------------------------------------------
void FullDuplexSerial2_num(FullDuplexSerial2 *self, int32_t val, int32_t base, int32_t signflag, int32_t digitsneeded, int32_t port)
{
  int32_t 	i, digit, r1, q1;
  // if signflag is nonzero, it indicates we should treat
  // val as signed; if it is > 1, it is a character we should
  // print for positive numbers (typically "+")
  if (signflag) {
    if (val < 0) {
      signflag = '-';
      val = -val;
    }
  }
  // make sure we will not overflow our buffer
  if (digitsneeded > 32) {
    digitsneeded = 32;
  }
  // accumulate the digits
  i = 0;
  do {
    if (val < 0) {
      // synthesize unsigned division from signed
      // basically shift val right by 2 to make it positive
      // then adjust the result afterwards by the bit we
      // shifted out
      // capture low bit
      r1 = val & 0x1;
      // divide val by 2
      q1 = Shr__(val, 1);
      digit = r1 + (2 * (q1 % base));
      val = 2 * (q1 / base);
      if (digit >= base) {
        (val++);
        digit = digit - base;
      }
    } else {
      digit = val % base;
      val = val / base;
    }
    if ((digit >= 0) && (digit <= 9)) {
      digit = digit + '0';
    } else {
      digit = (digit - 10) + 'A';
    }
    self->buf[(i++)] = digit;
    (--digitsneeded);
  } while (((val != 0) || (digitsneeded > 0)) && (i < 32));
  if (signflag > 1) {
    FullDuplexSerial2_tx(self, signflag, 0);
  }
  // now print the digits in reverse order
  while (i > 0) {
    FullDuplexSerial2_tx(self, self->buf[(--i)], port);
  }
}

//
// -----------------------------------------------------------------------
// print a signed decimal number
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_dec(FullDuplexSerial2 *self, int32_t val, int32_t port)
{
  FullDuplexSerial2_num(self, val, 10, 1, 0, port);
}

//
// -----------------------------------------------------------------------
// print an unsigned decimal number with the specified
// number of digits; 0 means just use as many as we need
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_decuns(FullDuplexSerial2 *self, int32_t val, int32_t digits, int32_t port)
{
  FullDuplexSerial2_num(self, val, 10, 0, digits, port);
}

//
// -----------------------------------------------------------------------
// print a hex number with the specified number
// of digits; 0 means just use as many as we need
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_hex(FullDuplexSerial2 *self, int32_t val, int32_t digits, int32_t port)
{
  int32_t 	mask;
  if ((digits > 0) && (digits < 8)) {
    mask = (1 << (4 * digits)) - 1;
    val &= mask;
  }
  FullDuplexSerial2_num(self, val, 16, 0, digits, port);
}

//
// -----------------------------------------------------------------------
// print a number in binary form
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_bin(FullDuplexSerial2 *self, int32_t val, int32_t digits, int32_t port)
{
  int32_t 	mask;
  if ((digits > 0) && (digits < 32)) {
    mask = (1 << digits) - 1;
    val &= mask;
  }
  FullDuplexSerial2_num(self, val, 2, 0, digits, port);
}

//
// -----------------------------------------------------------------------
// print a newline
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_nl(FullDuplexSerial2 *self, int32_t port)
{
  FullDuplexSerial2_tx(self, 13, port);
  FullDuplexSerial2_tx(self, 10, port);
}

//
// -----------------------------------------------------------------------
// C like formatted print
// -----------------------------------------------------------------------
//
/* ---
PUB printf(fmt = string(""), an=0, bn=0, cn=0, dn=0, en=0, fn=0)
RETURN printfex(0, fmt, an, bn, cn, dn, en, fn)

PUB printfex(port, fmt = string(""), an=0, bn=0, cn=0, dn=0, en=0, fn=0) | c, valptr, val
  valptr := @an
  repeat
    c := byte[fmt++]
    if (c == 0)
      quit
    if c == "%"
      c := byte[fmt++]
      if (c == 0)
        quit
      if (c == "%")
        tx(c, port)
        next
      val := long[valptr]
      valptr += 4
      case c
	"d": dec(val, port)
	"u": decuns(val, port)
	"x": hex(val, port)
	"s": str(val, port)
        "c": tx(val, port)
    elseif c == "\"
      c := byte[fmt++]
      if c == 0
        quit
      case c
        "n": nl( port)
        "r": tx(13, port)
        "t": tx(8, port)
        other: tx(c, port)
    else
      tx(c, port)
-
 */
//
// =======================================================================
//
// Status
//
// ================================ RX ===================================
//
// -----------------------------------------------------------------------
// returns size of receive buffer in bytes
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_rxsize(FullDuplexSerial2 *self, int32_t port)
{
  return FullDuplexSerial2_read(self, 0, -4, port);
}

//
// -----------------------------------------------------------------------
// returns number of bytes waiting in receive buffer
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_rxcount(FullDuplexSerial2 *self, int32_t port)
{
  return FullDuplexSerial2_read(self, 0, -3, port);
}

//
//
// ================================ TX ===================================
//
// -----------------------------------------------------------------------
// returns size of send buffer in bytes
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_txsize(FullDuplexSerial2 *self, int32_t port)
{
  return FullDuplexSerial2_write(self, 0, -4, port);
}

//
// -----------------------------------------------------------------------
// returns number of bytes free in send buffer
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_txcount(FullDuplexSerial2 *self, int32_t port)
{
  return FullDuplexSerial2_write(self, 0, -3, port);
}

//
// =======================================================================
//
// Async I/O
//
// ================================ RX ===================================
//
// -----------------------------------------------------------------------
// checks if rx port cmd = -1, signaling completion of last cmd or being ready for next cmd
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_check_rxready(FullDuplexSerial2 *self, int32_t port)
{
  int32_t result = 0;
  if (port) {
    result = self->rx2cmd;
  } else {
    result = self->rx1cmd;
  }
  return result;
}

//
// -----------------------------------------------------------------------
// waits until rx port cmd = -1, signaling completion of last cmd or being ready for next cmd
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_wait_rxready(FullDuplexSerial2 *self, int32_t port, int32_t timeout)
{
  int32_t result = 0;
  result = -2;
  if (port) {
    if (timeout > 0) {
      do {
        (timeout--);
        if (self->rx2cmd == (-1)) {
          result = self->rx2param;
          timeout = -10;
        }
      } while (!(timeout < 0));
      if (timeout > (-10)) {
        self->rx2cmd = -1;
        self->rx2param = -1;
      }
    } else {
      while (!(self->rx2cmd == (-1))) {
        Yield__();
      }
      result = self->rx2param;
    }
  } else {
    if (timeout > 0) {
      do {
        (timeout--);
        if (((int32_t *)&dat[1624])[0] == (-1)) {
          result = self->rx1param;
          timeout = -10;
        }
      } while (!(timeout < 0));
      if (timeout > (-10)) {
        self->rx1cmd = -1;
        self->rx1param = -1;
      }
    } else {
      while (!(self->rx1cmd == (-1))) {
        Yield__();
      }
      result = self->rx1param;
    }
  }
  return result;
}

//
// -----------------------------------------------------------------------
// receive a string (does not wait for completion - you may need to check rx_cmd if done or not later in your code)
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_strin_async(FullDuplexSerial2 *self, int32_t hubaddress, int32_t size, int32_t echo, int32_t port)
{
  int32_t 	stringflag;
  if (echo) {
    stringflag = 33554432;
  } else {
    stringflag = 16777216;
  }
  FullDuplexSerial2_read_async(self, hubaddress, size + stringflag, port);
}

//
// -----------------------------------------------------------------------
// receive a block from serial to memory of given size in bytes (does not wait for completion - you may need to check rxX_cmd for -1 [done] or not later in your code)
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_read_async(FullDuplexSerial2 *self, int32_t hubaddress, int32_t size, int32_t port)
{
  FullDuplexSerial2_wait_rxready(self, port, -1);
  if (port) {
    self->rx2param = hubaddress;
    self->rx2cmd = size;
  } else {
    self->rx1param = hubaddress;
    self->rx1cmd = size;
  }
}

//
// ================================ TX ===================================
//
// -----------------------------------------------------------------------
// checks if tx port cmd = -1, signaling completion of last cmd or being ready for next cmd
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_check_txready(FullDuplexSerial2 *self, int32_t port)
{
  int32_t result = 0;
  if (port) {
    result = self->tx2cmd;
  } else {
    result = self->tx1cmd;
  }
  return result;
}

//
// -----------------------------------------------------------------------
// waits until tx port cmd = -1, signaling completion of last cmd or being ready for next cmd
// -----------------------------------------------------------------------
//
int32_t FullDuplexSerial2_wait_txready(FullDuplexSerial2 *self, int32_t port)
{
  int32_t result = 0;
  if (port) {
    while (!(self->tx2cmd == (-1))) {
      Yield__();
    }
    result = self->tx2param;
  } else {
    while (!(self->tx1cmd == (-1))) {
      Yield__();
    }
    result = self->tx1param;
  }
  return result;
}

//
// -----------------------------------------------------------------------
// sends a byte (does not wait for completion - you may need to check tx1_cmd if done or not later in your code)
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_tx_async(FullDuplexSerial2 *self, int32_t val, int32_t port)
{
  FullDuplexSerial2_write_async(self, -1, val, port);
}

//
// -----------------------------------------------------------------------
// transmit a string (does not wait for completion - you may need to check tx1_cmd if done or not later in your code)
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_str_async(FullDuplexSerial2 *self, int32_t hubaddress, int32_t port)
{
  FullDuplexSerial2_write_async(self, hubaddress, -5, port);
}

//
// -----------------------------------------------------------------------
// sends a block from memory to serial of given size in bytes (does not wait for completion - you may need to check tx1_cmd if done or not later in your code)
// -----------------------------------------------------------------------
//
void FullDuplexSerial2_write_async(FullDuplexSerial2 *self, int32_t hubaddress, int32_t size, int32_t port)
{
  FullDuplexSerial2_wait_txready(self, port);
  if (port) {
    self->tx2param = hubaddress;
    self->tx2cmd = size;
  } else {
    self->tx1param = hubaddress;
    self->tx1cmd = size;
  }
}

// -----------------------------------------------------------------------
// fit 0'410
// -----------------------------------------------------------------------
